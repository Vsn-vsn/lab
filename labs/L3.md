## Q1
```python
class Topo:
    def __init__(self, ver):
        self.vertices = ver
        self.adj = {v: [] for v in range(ver)}

    def edgs(self, u, v):
        self.adj[u].append(v)

    def dfs(self, v, visited, stack):
        # current node is visited
        visited[v] = True

        for neighbor in self.adj[v]:
            if not visited[neighbor]:
                self.dfs(neighbor, visited, stack)
        stack.append(v)

    def topology(self):
        visited = [False] * self.vertices
        stack = []
        
        for i in range(self.vertices):
            if not visited[i]:
                self.dfs(i, visited, stack)

        # The stack contains the topologically sorted order (reversed)
        return stack[::-1]

n = int(input("Enter the number of vertices: "))
gr = Topo(n)

while True:
    u = int(input("Enter edge u in u->v: "))
    v = int(input("Enter edge v in u->v: "))
    gr.edgs(u, v)
    
    cond = input("Continue? y/n: ")
    if cond == 'n':
        break
topo_order = gr.topology()
print("Topological Sort Order:", topo_order)
```

## Q2
Logic
1) Tracking Nodes:
Use two lists:
Visited List: Keeps track of whether a node has been visited at least once during any DFS traversal.
Recursion Stack List: Keeps track of nodes in the current recursion stack (i.e., part of the current DFS path).

2) Depth-First Search (DFS):
For each node, start a DFS traversal if it hasn't been visited.
For every adjacent node:
If the adjacent node is in the current recursion stack, a cycle is detected.
If the adjacent node hasn't been visited, recursively apply DFS to it.

3) Backtracking:
After processing all adjacent nodes, remove the current node from the recursion stack.
After exploring all neighbors, the node is removed from the recursion stack (rec_stack[node] = False) to allow further independent DFS traversals.
```python
# Graph implementation and cycle detection
class Cyc:
    def __init__(self, ver):
        self.vertices = ver
        self.adj = {v: [] for v in range(ver)}

    def edgs(self, u, v):
        if u >= self.vertices or v >= self.vertices or u < 0 or v < 0:
            print("Invalid edge! Vertex index out of range.")
            return
        self.adj[u].append(v)

    def dfsinit(self):
        visited=[False]*self.vertices
        rec_stack=[False]*self.vertices
        for v in range(self.vertices):
            if not visited[v]:  
                if self.dfs(v, visited, rec_stack):  #cycle detected
                    return True
        return False

    def dfs(self, v, visited, rec_stack):
        visited[v] = True  # Mark the current node as visited
        rec_stack[v] = True  # Add the node to the recursion stack to check for cycle

        for neighbor in self.adj[v]:
            if not visited[neighbor]:  
                if self.dfs(neighbor, visited, rec_stack):  # Recurse on the neighbor
                    return True
            elif rec_stack[neighbor]:  # neighbor in the recursion stack => cycle is detected
                return True

        rec_stack[v] = False  # Remove the node from the recursion stack
        return False


n = int(input("Enter the number of vertices: "))
gr = Cyc(n)

while True:
    u = int(input("Enter edge u in u->v: "))
    v = int(input("Enter edge v in u->v: "))
    gr.edgs(u, v)
    
    cond = input("Continue? y/n: ")
    if cond == 'n':
        break

if gr.dfsinit():
    print("Graph contains a cycle")
else:
    print("Graph does not contain a cycle")
```