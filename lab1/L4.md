## Q1
1) Compute the in-degree of each vertex.
2) Initialize a queue with all vertices that have zero in-degree.
3) While the queue is not empty:
        Remove a vertex from the queue and add it to the topological order.
        Decrease the in-degree of its neighbors by one.
        If any neighborâ€™s in-degree becomes zero, add it to the queue.
4) If the topological order contains all vertices, it's a valid topological sort. If not, the graph contains a cycle.
```python
class Topo:
    def __init__(self, ver):
        self.vertices = ver
        self.adj = {v: [] for v in range(ver)}  # adjacency list to store graph
        self.in_degree = {v: 0 for v in range(ver)}  # in-degree of each vertex

    def edgs(self, u, v):
        self.adj[u].append(v)  # add directed edge u->v
        self.in_degree[v] += 1  # increase in-degree of vertex v

    def topology(self):
        queue = [v for v in range(self.vertices) if self.in_degree[v] == 0]
        
        topo_order = []

        while queue:
            # Process node with in-degree 0 (dequeue)
            node = queue.pop(0)
            topo_order.append(node)
            
            # Reduce in-degree of all neighbors
            for neighbor in self.adj[node]:
                self.in_degree[neighbor] -= 1
                if self.in_degree[neighbor] == 0:
                    queue.append(neighbor)

        if len(topo_order) == self.vertices:
            return topo_order
        else:
            return "Cycle detected, topological sort not possible"

# Main Execution:
n = int(input("Enter the number of vertices: "))
gr = Topo(n)

while True:
    u = int(input("Enter edge u in u->v: "))
    v = int(input("Enter edge v in u->v: "))
    gr.edgs(u, v)
    
    cond = input("Continue? y/n: ")
    if cond == 'n':
        break

topo_order = gr.topology()
print("Topological Sort Order:", topo_order)

```

## Q2
To detect cycles in an undirected graph using BFS, we need a way to distinguish between a normal traversal (where we reach a node from its parent) and a cycle (where we encounter a node that we've already visited but isn't the parent of the current node).
```python
class Cyc:
    def __init__(self, ver):
        self.vertices = ver
        self.adj = {v: [] for v in range(ver)}

    def edgs(self, u, v):
        if u >= self.vertices or v >= self.vertices or u < 0 or v < 0:
            print("Invalid edge! Vertex index out of range.")
            return
        self.adj[u].append(v)

    def bfsinit(self):
        visited = [False] * self.vertices
        for v in range(self.vertices):
            if not visited[v]:  
                if self.bfs(v, visited):  # cycle detected in BFS
                    return True
        return False

    def bfs(self, start, visited):
        parent = [-1] * self.vertices  # to track the parent of each node
        queue = [start]  # using a list as a queue
        visited[start] = True

        while queue:
            node = queue.pop(0)  # dequeue operation

            for neighbor in self.adj[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    parent[neighbor] = node
                    queue.append(neighbor)
                elif parent[node] != neighbor:  # If visited and not the parent, cycle detected
                    return True
        return False


n = int(input("Enter the number of vertices: "))
gr = Cyc(n)

while True:
    u = int(input("Enter edge u in u->v: "))
    v = int(input("Enter edge v in u->v: "))
    gr.edgs(u, v)
    
    cond = input("Continue? y/n: ")
    if cond == 'n':
        break

if gr.bfsinit():
    print("Graph contains a cycle")
else:
    print("Graph does not contain a cycle")

```

## Q3
Graph Representation: The graph is given as a dictionary where each key is a city, and the value is another dictionary of neighboring cities with corresponding distances.
Generate All Permutations: Since we need to visit all cities exactly once, we generate all possible routes (permutations) of the cities.
Compute Total Distance: For each permutation, calculate the total distance by summing up the distances between consecutive cities in the path.
Find the Shortest Path: Track the minimum distance and corresponding path.
```python

```