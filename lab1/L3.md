## Q1
```python
class Topo:
    def __init__(self, ver):
        self.vertices = ver
        self.adj = {v: [] for v in range(ver)}

    def edgs(self, u, v):
        self.adj[u].append(v)

    def dfs(self, v, visited, stack):
        # current node is visited
        visited[v] = True

        for neighbor in self.adj[v]:
            if not visited[neighbor]:
                self.dfs(neighbor, visited, stack)
        stack.append(v)

    def topology(self):
        visited = [False] * self.vertices
        stack = []
        
        for i in range(self.vertices):
            if not visited[i]:
                self.dfs(i, visited, stack)

        # The stack contains the topologically sorted order (reversed)
        return stack[::-1]

n = int(input("Enter the number of vertices: "))
gr = Topo(n)

while True:
    u = int(input("Enter edge u in u->v: "))
    v = int(input("Enter edge v in u->v: "))
    gr.edgs(u, v)
    
    cond = input("Continue? y/n: ")
    if cond == 'n':
        break
topo_order = gr.topology()
print("Topological Sort Order:", topo_order)
```

## Q2
Logic
1) Tracking Nodes:
Use two lists:
Visited List: Keeps track of whether a node has been visited at least once during any DFS traversal.
Recursion Stack List: Keeps track of nodes in the current recursion stack (i.e., part of the current DFS path).

2) Depth-First Search (DFS):
For each node, start a DFS traversal if it hasn't been visited.
For every adjacent node:
If the adjacent node is in the current recursion stack, a cycle is detected.
If the adjacent node hasn't been visited, recursively apply DFS to it.

3) Backtracking:
After processing all adjacent nodes, remove the current node from the recursion stack.
After exploring all neighbors, the node is removed from the recursion stack (rec_stack[node] = False) to allow further independent DFS traversals.
```python
# Graph implementation and cycle detection
class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = {v: [] for v in range(vertices)}

    def add_edge(self, u, v):
        self.adj_list[u].append(v)

    def detect_cycle(self):
        visited = [False] * self.vertices  # Tracks visited nodes
        rec_stack = [False] * self.vertices  # Tracks nodes in the current recursion stack

        # Perform DFS from each node
        for node in range(self.vertices):
            if not visited[node]:  # Only visit unvisited nodes
                if self._dfs(node, visited, rec_stack):
                    return True  # Cycle found

        return False  # No cycle detected

    def _dfs(self, node, visited, rec_stack):
        # Mark the current node as visited and add it to the recursion stack
        visited[node] = True
        rec_stack[node] = True

        # Explore adjacent nodes
        for neighbor in self.adj_list[node]:
            if not visited[neighbor]:  # If neighbor is not visited, recurse
                if self._dfs(neighbor, visited, rec_stack):
                    return True
            elif rec_stack[neighbor]:  # If neighbor is in recursion stack, cycle detected
                return True

        # Remove the current node from the recursion stack before backtracking
        rec_stack[node] = False
        return False

# Example usage
g = Graph(6)
g.add_edge(0, 1)
g.add_edge(1, 2)
g.add_edge(2, 0)  # Cycle here
g.add_edge(3, 4)
g.add_edge(4, 5)

if g.detect_cycle():
    print("Cycle detected in the graph.")
else:
    print("No cycle in the graph.")

```