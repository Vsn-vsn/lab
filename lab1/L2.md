## Q1
```python
class Graph:
    def __init__(self):
        # Dictionary to store adjacency list representation of the graph
        self.graph = {}

    def add_edge(self, u, v):
        # Add an edge from u to v
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)

    def display_edges(self):
        # Display all the edges in the graph
        for node in self.graph:
            for neighbor in self.graph[node]:
                print(f"({node} —> {neighbor})")
# Create the graph
g = Graph()
# Add edges
g.add_edge(0, 1)
g.add_edge(1, 2)
g.add_edge(2, 0)
g.add_edge(2, 1)
g.add_edge(3, 2)
g.add_edge(4, 5)
g.add_edge(5, 4)
# Display edges
g.display_edges()
```

## Q2
```python
class WeightedGraph:
    def __init__(self):
        # Dictionary to store adjacency list representation of the graph
        self.graph = {}

    def add_edge(self, u, v, weight):
        # Add an edge from u to v with a specified weight
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append((v, weight))

    def display_edges(self):
        # Display all the edges in the graph with weights
        for node in self.graph:
            for neighbor, weight in self.graph[node]:
                print(f"({node} —> {neighbor}, {weight})")

g = WeightedGraph()

# Add edges with weights
g.add_edge(0, 1, 6)
g.add_edge(1, 2, 7)
g.add_edge(2, 0, 5)
g.add_edge(2, 1, 4)
g.add_edge(3, 2, 10)
g.add_edge(4, 5, 1)
g.add_edge(5, 4, 3)

g.display_edges()
```

## Q3
```python
class UndirectedWeightedGraph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v, weight):
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))  # Add reverse edge for undirected graph

    def print_adjacency_list(self):
        print("Adjacency List:")
        for node in self.graph:
            edges = ", ".join([f"({neighbor}, {weight})" for neighbor, weight in self.graph[node]])
            print(f"{node}: {edges}")

    def print_adjacency_matrix(self):
        print("\nAdjacency Matrix:")
        nodes = sorted(self.graph.keys())  # Sort nodes for consistent order
        node_indices = {node: i for i, node in enumerate(nodes)}
        n = len(nodes)
        
        # Initialize matrix with 0s
        matrix = [[0] * n for _ in range(n)]
        
        for u in self.graph:
            for v, weight in self.graph[u]:
                i, j = node_indices[u], node_indices[v]
                matrix[i][j] = weight
        
        print("   " + " ".join(nodes))  # Header
        for i, row in enumerate(matrix):
            print(f"{nodes[i]}: " + " ".join(map(str, row)))

# Create the graph
g = UndirectedWeightedGraph()

# Add edges
g.add_edge("A", "B", 1)
g.add_edge("A", "E", 2)
g.add_edge("A", "C", 3)
g.add_edge("B", "C", 4)
g.add_edge("C", "D", 5)
g.add_edge("D", "E", 6)

# Print adjacency list and adjacency matrix
g.print_adjacency_list()
g.print_adjacency_matrix()

```