## Q1
```python
class MyQueue:
    def __init__(self):
        self.stack1 = []  # Stack 1
        self.stack2 = []  # Stack 2

    def push(self, x):
        # Add element to stack1
        self.stack1.append(x)

    def pop(self):
        # If the queue is empty, return -1
        if self.empty():
            return -1

        # Move elements from stack1 to stack2 except the last one
        while len(self.stack1) > 1:
            self.stack2.append(self.stack1.pop())

        # Pop the last element from stack1 (the front of the queue)
        popped = self.stack1.pop()

        # Move elements back from stack2 to stack1
        while self.stack2:
            self.stack1.append(self.stack2.pop())

        return popped

    def empty(self):
        # Check if stack1 is empty
        return len(self.stack1) == 0

# Example Usage
queue = MyQueue()
queue.push(1)
queue.push(2)
queue.push(3)
print(queue.pop())  # Output: 1
print(queue.pop())  # Output: 2
print(queue.empty())  # Output: False
```

## Q2
```python
# Python implementation of the graph

# Using adjacency list representation
class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = {str(v): [] for v in range(1, vertices + 1)}

    def add_edge(self, u, v, weight):
        self.adj_list[str(u)].append((v, weight))

    def print_adj_list(self):
        print("Adjacency List:")
        print(self.adj_list)

    def to_adj_matrix(self):
        adj_matrix = [[0] * self.vertices for _ in range(self.vertices)]
        for u in self.adj_list:
            for v, weight in self.adj_list[u]:
                adj_matrix[int(u) - 1][v - 1] = weight
        return adj_matrix

    def print_adj_matrix(self):
        adj_matrix = self.to_adj_matrix()
        print("Adjacency Matrix:")
        for row in adj_matrix:
            print(row)

# Example usage
vertices = 4
graph = Graph(vertices)

# Adding edges as per the given graph
graph.add_edge(1, 2, 1)
graph.add_edge(1, 3, 1)
graph.add_edge(1, 4, 5)
graph.add_edge(3, 4, 4)
graph.add_edge(4, 1, 5)
graph.add_edge(2, 3, 3)

# Printing adjacency list and matrix
graph.print_adj_list()
graph.print_adj_matrix()

```

## Q3
```python
# Compute Euclidean distance and sort using Bubble Sort

def compute_euclidean_distance(x, y):
    distances = []
    for i in range(len(x)):
        distance = ((x[i] - y[i]) ** 2) ** 0.5
        distances.append(distance)
    return distances

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# Example usage
X = [3, 5, 7, 9]
Y = [1, 4, 6, 8]

distances = compute_euclidean_distance(X, Y)
print("Euclidean Distances:", distances)

sorted_distances = bubble_sort(distances)
print("Sorted Distances:", sorted_distances)
```

## Q4
```python
# Implementation of Binary Search Tree with Traversals

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if self.root is None:
            self.root = Node(value)
        else:
            self._insert(self.root, value)

    def _insert(self, current, value):
        if value < current.value:
            if current.left is None:
                current.left = Node(value)
            else:
                self._insert(current.left, value)
        else:
            if current.right is None:
                current.right = Node(value)
            else:
                self._insert(current.right, value)

    def inorder(self, node, result):
        if node:
            self.inorder(node.left, result)
            result.append(node.value)
            self.inorder(node.right, result)

    def preorder(self, node, result):
        if node:
            result.append(node.value)
            self.preorder(node.left, result)
            self.preorder(node.right, result)

    def postorder(self, node, result):
        if node:
            self.postorder(node.left, result)
            self.postorder(node.right, result)
            result.append(node.value)

# Example usage
bst = BinarySearchTree()
values = [25, 15, 50, 10, 22, 35, 70, 4, 12, 18, 24, 31, 44, 66, 90]
for value in values:
    bst.insert(value)

inorder_result = []
bst.inorder(bst.root, inorder_result)
print("InOrder(root) visits nodes in the following order:", inorder_result)

preorder_result = []
bst.preorder(bst.root, preorder_result)
print("A Pre-order traversal visits nodes in the following order:", preorder_result)

postorder_result = []
bst.postorder(bst.root, postorder_result)
print("A Post-order traversal visits nodes in the following order:", postorder_result)
```